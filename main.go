package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"gorm.io/gorm/schema"
	"html/template"
	"os"
	"path/filepath"
	"reflect"
	"strconv"
	"strings"
)

var (
	srcFile    = flag.String("source", "", "source file")
	dstFile    = flag.String("destination", "", "output file")
	structName = flag.String("struct", "", "struct name")
	pkgName    = flag.String("package", "model", "output file package")
)

const tmpl = `// Code generated by cmd/schema_column_parser/main.go; DO NOT EDIT.

package {{.Package}}

const (
{{- range .Fields}}
	{{$.StructName}}_{{.Name}} = "{{.DBName}}"
{{- end}}
)
`

type Params struct {
	Package    string
	StructName string
	Fields     []TableField
}

func main() {
	flag.Parse()
	if *structName == "" || *dstFile == "" {
		flag.Usage()
		os.Exit(1)
	}

	_, fields, err := loadStructFields(*srcFile, *structName)
	if err != nil {
		_, _ = fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}

	params := Params{
		Package:    *pkgName,
		StructName: *structName,
		Fields:     fields,
	}

	var buf bytes.Buffer
	t := template.Must(template.New("").Parse(tmpl))
	if err = t.Execute(&buf, params); err != nil {
		_, _ = fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}

	src, err := format.Source(buf.Bytes())
	if err != nil {
		_, _ = fmt.Fprintf(os.Stderr, "format error: %v\n%s", err, buf.Bytes())
		os.Exit(1)
	}

	if err = os.MkdirAll(filepath.Dir(*dstFile), 0755); err != nil {
		panic(err)
	}
	if err = os.WriteFile(*dstFile, src, 0644); err != nil {
		panic(err)
	}
	fmt.Println("generated:", dstFile)
}

type TableField struct {
	Name   string
	DBName string
}

func loadStructFields(srcFile, structName string) (tableName string, fields []TableField, err error) {
	// parse source file
	fSet := token.NewFileSet()
	fileAst, err := parser.ParseFile(fSet, srcFile, nil, parser.ParseComments)
	if err != nil {
		return "", nil, err
	}

	// gorm default naming strategy
	naming := schema.NamingStrategy{}

	//tableName, err = getTableName(fileAst, structName, naming)
	//if err != nil {
	//	return "", nil, err
	//}

	// find TypeSpec in AST
	for _, decl := range fileAst.Decls {
		gen, ok := decl.(*ast.GenDecl)
		if !ok || gen.Tok != token.TYPE {
			continue
		}
		for _, spec := range gen.Specs {
			// skip non-structs
			ts, aok := spec.(*ast.TypeSpec)
			if !aok || ts.Name.Name != structName {
				continue
			}
			st, tok := ts.Type.(*ast.StructType)
			if !tok {
				continue
			}

			// loop fields
			for _, f := range st.Fields.List {
				goName, colName := getColumnNames(f, naming)
				if goName == "" {
					continue
				}

				fields = append(fields, struct{ Name, DBName string }{
					Name:   goName,
					DBName: colName,
				})
			}

			return tableName, fields, nil
		}
	}
	return "", nil, fmt.Errorf("struct %q not found in %s", structName, srcFile)
}

func getTableName(fileAst *ast.File, structName string, naming schema.NamingStrategy) (string, error) {
	for _, decl := range fileAst.Decls {
		fn, ok := decl.(*ast.FuncDecl)
		if !ok || fn.Name.Name != "TableName" || fn.Type.Results == nil {
			continue
		}

		if len(fn.Type.Results.List) != 1 {
			continue
		}

		if ident, ok := fn.Type.Results.List[0].Type.(*ast.Ident); !ok || ident.Name != "string" {
			continue
		}

		if fn.Recv == nil || len(fn.Recv.List) != 1 {
			continue
		}

		// check receiver is structName or *structName
		switch recv := fn.Recv.List[0].Type.(type) {
		case *ast.StarExpr:
			if id, ok := recv.X.(*ast.Ident); !ok || id.Name != structName {
				continue
			}
		case *ast.Ident:
			if recv.Name != structName {
				continue
			}
		default:
			continue
		}

		// fine table name return
		for _, stmt := range fn.Body.List {
			if ret, ok := stmt.(*ast.ReturnStmt); ok && len(ret.Results) == 1 {
				if lit, ok := ret.Results[0].(*ast.BasicLit); ok && lit.Kind == token.STRING {
					tbl, err := strconv.Unquote(lit.Value)
					if err != nil {
						return "", fmt.Errorf("unquote TableName literal: %w", err)
					}
					return tbl, nil
				}
			}
		}
	}

	// use default if TableName not found
	return naming.TableName(structName), nil
}

func getColumnNames(f *ast.Field, naming schema.NamingStrategy) (goName, colName string) {
	// skip anonymous fields
	if len(f.Names) == 0 {
		return "", ""
	}

	goName = f.Names[0].Name

	if f.Tag != nil {
		if raw, err := strconv.Unquote(f.Tag.Value); err == nil {
			tag := reflect.StructTag(raw)
			// gorm:"column:xxx;â€¦"
			for _, part := range strings.Split(tag.Get("gorm"), ";") {
				if kv := strings.SplitN(part, ":", 2); len(kv) == 2 && kv[0] == "column" {
					return goName, kv[1]
				}
			}
		}
	}

	return goName, naming.ColumnName("", goName)
}
